# Interweave

[![Build Status](https://travis-ci.org/milesj/interweave.svg?branch=master)](https://travis-ci.org/milesj/interweave)

Interweave is a robust React library that can...

- Safely render HTML without using `dangerouslySetInnerHTML`.
- Safely strip HTML tags.
- Automatic XSS and injection protection.
- Clean HTML attributes using filters.
- Interpolate components using matchers.
- Autolink URLs, IPs, emails, and hashtags.
- Render Emoji and emoticon characters.
- And much more!

## Requirements

- React 15/16+
- IE 10+
- Emoji support: `fetch`, `sessionStorage`

## Installation

Interweave requires React as a peer dependency.

```
npm install interweave react --save
// Or
yarn add interweave react
```

## Usage

Interweave can primarily be used with the `Interweave` and `Markup` components, both of which
provide an easy, straight-forward implementation for safely
[parsing and rendering HTML](#html-parsing) without using `dangerouslySetInnerHTML`
([React][dangerhtml]).

The `Interweave` component has the additional benefit of utilizing [filters](#filters),
[matchers](#matchers), and callbacks.

```javascript
import Interweave from 'interweave';

<Interweave tagName="div" content="This string <b>contains</b> HTML." />;
```

#### Props

- `content` (string) - The string to render and apply matchers and filters to. Supports HTML.
- `emptyContent` (node) - React node to render if no content was rendered.
- `tagName` (div | span | p | fragment) - The HTML element tag name to wrap the output with.
  Defaults to "div".
- `filters` (Filter[]) - Filters to apply to this instance.
- `matchers` (Matcher[]) - Matchers to apply to this instance.
- `disableFilters` (boolean) - Disables all filters.
- `disableMatchers` (boolean) - Disables all matchers.
- `disableLineBreaks` (boolean) - Disables automatic line break conversion.
- `disableWhitelist` (boolean) - Disables automatic tag and attribute filtering.
- `noHtml` (boolean) - Strips HTML tags from the content string while parsing. Also strips HTML
  generated by matchers.
- `noHtmlExceptMatchers` (boolean) - Like the former, but allows HTML generated by matchers.
- `onBeforeParse` (func) - Callback that fires before parsing. Is passed the source string and must
  return a string.
- `transform` (func) - Callback that fires during parsing. Is passed the parsed DOM node, and can
  return an element, null to skip the node, or undefined to use the default element.
- `onAfterParse` (func) - Callback that fires after parsing. Is passed an array of strings/elements
  and must return an array.

### Markup

Unlike the `Interweave` component, the `Markup` component does not support matchers, filters, or
callbacks. This component is preferred when rendering strings that contain HTML is the primary use
case.

```javascript
import { Markup } from 'interweave';

<Markup content="This string <b>contains</b> HTML." />;
```

#### Props

The `Markup` component only supports the `content`, `emptyContent`, `tagName`, `disableLineBreaks`,
`disableWhitelist`, `noHtml`, and `noHtmlExceptMatchers` props mentioned previously.

## Documentation

- [Matchers](#matchers)
  - [Creating A Matcher](#creating-a-matcher)
  - [Rendered Elements](#rendered-elements)
- [Filters](#filters)
  - [Creating A Filter](#creating-a-filter)
- Extensions
  - [Autolinking](./packages/interweave-autolink)
  - [Emojis](./packages/interweave-emoji)
  - [Emoji Picker](./packages/interweave-emoji-picker)
- [HTML Parsing](#html-parsing)
  - [Tag Whitelist](#tag-whitelist)
  - [Attribute Whitelist](#attribute-whitelist)
  - [By-passing the Whitelist](#by-passing-the-whitelist)
  - [Replacing Elements](#replacing-elements)
  - [Disabling HTML](#disabling-html)
- [Global Configuration](#global-configuration)
- [Server-side Rendering](#server-side-rendering)

### Matchers

Matchers are the backbone of Interweave as they allow arbitrary insertion of React elements into
strings, through the use of regex matching. This feature is quite powerful and opens up many
possibilities.

It works by matching patterns within a string, deconstructing it into tokens, and reconstructing it
back into an array of strings and React elements, therefore, permitting it to be rendered by React's
virtual DOM layer. For example, take the following string "Check out my website,
github.com/milesj!", and a `UrlMatcher`, you'd get the following array.

```javascript
['Check out my website, ', <Url>github.com/milesj</Url>, '!'];
```

Matchers can be passed to each instance of `Interweave`. When adding a matcher, a unique name must
be passed to the constructor.

```javascript
import Interweave from 'interweave';

<Interweave matchers={[new CustomMatcher('foo')]} />;
```

To disable all matchers per instance, pass the `disableMatchers` prop.

```javascript
<Interweave disableMatchers />
```

To disable a single matcher, you can pass a prop that starts with "no", and ends with the unique
name of the matcher (the one passed to the constructor). Using the example above, you can pass a
`noFoo` prop.

```javascript
<Interweave noFoo />
```

#### Creating A Matcher

To create a custom matcher, implement a class that extends the base `Matcher` class, or use a plain
object. Both approaches will require the following methods to be defined (excluding callbacks).

- `match(string)` - Match the passed string using a regex pattern. This method must return `null` if
  no match is found, else it must return an object with a `match` key and the matched value.
  Furthermore, any additional keys defined in this object will be passed as props to the created
  element.
- `replaceWith(match, props)` - Returns a React element that replaces the matched content in the
  string. The match is passed as the 1st argument, and any matched props or parent props are passed
  as the 2nd argument.
- `createElement(match, props)` - The same as `replaceWith` but used in object matchers.
- `asTag()` - The HTML tag name of the replacement element.
- `onBeforeParse(content, props)` (func) - Callback that fires before parsing. Is passed the source
  string and must return a string.
- `onAfterParse(nodes, props)` (func) - Callback that fires after parsing. Is passed an array of
  strings/elements and must return an array.

> Using the plain object approach requires more implementation and a higher overhead.

```javascript
import { Matcher } from 'interweave';

function match(string) {
  const matches = string.match(/foo/);

  if (!matches) {
    return null;
  }

  return {
    match: matches[0],
    extraProp: 'foo', // or matches[1], etc
  };
}

// Class
class CustomMatcher extends Matcher {
  match(string) {
    return match(string);
  }

  replaceWith(match, props) {
    return <span {...props}>{match}</span>;
  }

  asTag() {
    return 'span';
  }
}

const matcher = new CustomMatcher('foo');

// Object
const matcher = {
  inverseName: 'noFoo',
  propName: 'foo',
  asTag: () => 'span',
  createElement: (match, props) => <span {...props}>{match}</span>,
  match,
};
```

To ease the matching process, there is a `doMatch` method on `Matcher` that handles the `null` and
object building logic. Simply pass it a regex pattern and a callback to build the object.

```javascript
class CustomMatcher extends Matcher {
  // ...

  match(string) {
    return this.doMatch(string, /foo/, matches => ({
      extraProp: 'foo',
    }));
  }
}
```

#### Rendered Elements

When a match is found, a React element is rendered (from a React component) from either the
matcher's `replaceWith` method, or from a factory. What's a factory you ask? Simply put, it's a
function passed to the constructor of a matcher, allowing the rendered element to be customized for
built-in or third-party matchers.

To define a factory, simply pass a function to the 3rd argument of a matcher constructor. The
factory function receives the same arguments as `replaceWith`.

```javascript
new CustomMatcher('foo', {}, (match, props) => <span {...props}>{match}</span>);
```

> Elements returned from `replaceWith` or the factory must return an HTML element with the same tag
> name as defined by `asTag`.

### Filters

Filters provide an easy way of cleaning HTML attributes and nodes during the
[parsing cycle](#html-parsing). This is especially useful for `src` and `href` attributes.

Filters can be added to each instance of `Interweave`

```javascript
<Interweave filters={[new LinkFilter()]} />
```

To disable all filters, pass the `disableFilters` prop.

```javascript
<Interweave disableFilters />
```

#### Creating A Filter

Creating a custom filter is easy. Simply extend the base `Filter` class, or use a plain object, and
define the `attribute` or `node` methods. These methods receive the attribute or tag name as the 1st
argument, and the value as the 2nd, respectively.

```javascript
import { Filter } from 'interweave';

// Class
class LinkFilter extends Filter {
  attribute(name, value) {
    if (name === 'href') {
      return encodeURIComponent(value);
    }

    return value;
  }

  node(name, node) {
    if (name === 'a') {
      node.setAttribute('target', '_blank');
    }

    return node;
  }
}

const filter = new LinkFilter();

// Object
const filter = {
  attribute: (name, value) => value,
  node: (name, node) => node,
};
```

> Attribute values and nodes must be returned from filter methods!

> Returning `null` for a node will remove it from the DOM tree.

### HTML Parsing

Interweave doesn't rely on an HTML parser for rendering HTML safely, instead, it uses the DOM
itself. It accomplishes this by using `DOMImplementation.createHTMLDocument` ([MDN][domhtml]), which
creates an HTML document in memory, allowing us to easily set markup, aggregate nodes, and generate
React elements. This implementation is supported by all modern browsers and IE9+.

`DOMImplementation` has the added benefit of not requesting resources (images, scripts, etc) until
the document has been rendered to the page.This provides an extra layer of security by avoiding
possible CSRF and arbitrary code execution.

Furthermore, Interweave manages a whitelist of both HTML tags and attributes, further increasing
security, and reducing the risk of XSS and vulnerabilities.

#### Tag Whitelist

Interweave keeps a mapping of valid [HTML tags to parsing configurations][tagwhitelist]. These
configurations handle the following rules and processes.

- Defines the type of rule: allow or deny.
- Defines the type of tag: inline, block, inline-block.
- Flags whether inline children can be rendered.
- Flags whether block children can be rendered.
- Flags whether children of the same tag name can be rendered.
- Maps the parent tags the current element can render in.
- Maps the child tags the current element can render.

Lastly, any tag not found in the mapping will be flagged using the rule "deny", and promptly not
rendered.

The following tags are not supported, but their children will still be rendered.

`acronym`, `area`, `base`, `basefont`, `bdi`, `bdo`, `bgsound`, `big`, `blink`, `body`, `caption`,
`center`, `col`, `colgroup`, `command`, `content`, `data`, `datalist`, `dialog`, `dir`, `font`,
`form`, `head`, `hgroup`, `html`, `image`, `input`, `isindex`, `keygen`, `link`, `listing`,
`marquee`, `menu`, `menuitem`, `meta`, `meter`, `multicol`, `nobr`, `noembed`, `noframes`,
`noscript`, `optgroup`, `option`, `param`, `plaintext`, `progress`, `rp`, `rt`, `rtc`, `ruby`,
`select`, `shadow`, `slot`, `small`, `spacer`, `strike`, `template`, `textarea`, `title`, `tt`,
`wbr`, `xmp`

The following tags and their children will never be rendered, even when the whitelist is disabled.

`applet`, `canvas`, `embed`, `frame`, `frameset`, `iframe`, `object`, `script`, `style`

#### Attribute Whitelist

Interweave takes parsing a step further, by also [filtering](#filters) attribute values and HTML
nodes. Like tags, a mapping of valid [HTML attributes to parser rules][attrwhitelist] exist. A rule
can be one of: allow and cast to string (default), allow and cast to number, allow and cast to
boolean, and finally, deny.

Also like the tag whitelist, any attribute not found in the mapping is ignored.

#### By-passing the Whitelist

If need be, the whitelist can be disabled with the `disableWhitelist` prop. This is highly
discouraged as it opens up possible XSS and injection attacks, and should only be used if the markup
passed to `Interweave` has been sanitized beforehand.

That being said, specific tags like `script`, `iframe`, `applet`, and a few others are consistently
removed.

#### Replacing Elements

By default, Interweave converts tags to an `Element` React component, which renders the appropriate
DOM node. For custom block-level elements, the `transform` function prop can be passed.

This function receives the parsed DOM node, and can return either a React element (which is inserted
into the React element tree), undefined to use the default `Element` component, or null to skip the
element entirely.

For example, to replace `blockquote` elements with a custom element:

```javascript
const transform = node => {
  if (node.tagName === 'BLOCKQUOTE') {
    return <CustomElement {...node.attributes} />;
  }
};

<Interweave transform={transform} />;
```

Note that `transform` is run before checking the whitelist, allowing you to use non-whitelisted tags
in a controlled way. Blacklisted tags like `script` will not be transformed.

#### Disabling HTML

The HTML parser cannot be disabled, however, a `noHtml` boolean prop can be passed to both the
`Interweave` and `Markup` components. This prop will mark all HTML elements as pass-through, simply
rendering text nodes recursively, including matchers.

If you want to strip user provided HTML, but allow HTML from matchers, use the
`noHtmlExceptMatchers` prop instead.

### Global Configuration

In an older version of `Interweave`, there was this concept of global configuration, in which
filters, matchers, and even nested props can be defined. This configuration would then be passed to
all instances of `Interweave` or `Markup`. Since it was using globals, this approach had its fair
share of problems.

In newer versions, we suggest composing around `Interweave` using a custom component in your
application. This provides more options for customization, like the choice between Twitter and
Instagram hashtags, or PNG or SVG emojis.

```javascript
import React from 'react';
import PropTypes from 'prop-types';
import { stripHexcode } from 'emojibase';
import BaseInterweave, { FilterShape, MatcherShape } from 'interweave';
import { IpMatcher, UrlMatcher, EmailMatcher, HashtagMatcher } from 'interweave-autolink';
import { EmojiMatcher, withEmojiData } from 'interweave-emoji';

const globalFilters = [new CustomFilter()];

const globalMatchers = [
  new IpMatcher('ip'),
  new UrlMatcher('url'),
  new EmailMatcher('email'),
  new HashtagMatcher('hashtag'),
  new EmojiMatcher('emoji', {
    convertEmoticon: true,
    convertShortcode: true,
    convertUnicode: true,
  }),
];

function getEmojiPath(hexcode, enlarged) {
  return `//cdn.jsdelivr.net/emojione/assets/3.1/png/${enlarged ? 64 : 32}/${stripHexcode(
    hexcode,
  ).toLowerCase()}.png`;
}

function Interweave({ filters, matchers, twitter, instagram, ...props }) {
  let hashtagUrl = '';

  if (twitter) {
    hashtagUrl = 'https://twitter.com/hashtag/{{hashtag}}';
  } else if (instagram) {
    hashtagUrl = 'https://instagram.com/explore/tags/{{hashtag}}';
  }

  return (
    <BaseInterweave
      filters={[...globalFilters, ...filters]}
      matchers={[...globalMatchers, ...matchers]}
      hashtagUrl={hashtagUrl}
      emojiPath={getEmojiPath}
      newWindow
      {...props}
    />
  );
}

Interweave.propTypes = {
  filters: PropTypes.arrayOf(FilterShape),
  matchers: PropTypes.arrayOf(MatcherShape),
  twitter: PropTypes.bool,
  instagram: PropTypes.bool,
};

Interweave.defaultProps = {
  filters: [],
  matchers: [],
  twitter: false,
  instagram: false,
};

export default withEmojiData(Interweave);
```

### Server-side Rendering

Interweave utilizes the DOM to parse and validate HTML, and as such, is not server-side renderable
out of the box. However, this is easily mitigated with [JSDOM][jsdom]. To begin, install JSDOM.

```
npm install jsdom --save-dev
// Or
yarn add jsdom --dev
```

Add instantiate an instance, configured to your liking. Once this instance is configured, you can
then render your React components without much issue (hopefully).

```javascript
import React from 'react';
import ReactDOMServer from 'react-dom/server';
import JSDOM from 'jsdom';

global.window = new JSDOM('', { url: 'http://localhost' });
global.document = global.window.document;
```

[dangerhtml]: https://reactjs.org/docs/dom-elements.html
[domhtml]: https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createHTMLDocument
[tagwhitelist]: https://github.com/milesj/interweave/blob/master/src/constants.js#L88
[attrwhitelist]: https://github.com/milesj/interweave/blob/master/src/constants.js#L381
[jsdom]: https://github.com/tmpvar/jsdom
