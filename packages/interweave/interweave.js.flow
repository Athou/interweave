import React from 'react';
import PropTypes from 'prop-types';
import { Matcher } from 'interweave';

declare module 'interweave' {
  declare export type AfterParseCallback = (content: React$Node[], props: Object) => React$Node[];

  declare export type BeforeParseCallback = (content: string, props: Object) => string;

  declare export class Filter {
    attribute: string;
    constructor(attribute: string): this;
    filter(value: string): string;
  }

  declare export type MatcherFactory = (match: string, props: Object) => React$Node;

  declare export type MatchCallback = (matches: string[]) => Object;

  declare export type MatchResponse = {
    match: string,
    [key: string]: string,
  };

  declare export class Matcher<T> {
    factory: ?MatcherFactory;
    inverseName: string;
    options: T;
    propName: string;
    constructor(name: string, options?: T, factory?: ?MatcherFactory): this;
    createElement(match: string, props?: Object): React$Node;
    replaceWith(match: string, props?: Object): React$Node;
    asTag(): string;
    match(string: string): ?MatchResponse;
    doMatch(string: string, pattern: string | RegExp, callback: MatchCallback): ?MatchResponse;
    onAfterParse(content: React$Node[], props: Object): React$Node[];
    onBeforeParse(content: string, props: Object): string;
  }

  declare export type MarkupProps = {
    content: string,
    disableLineBreaks: boolean,
    disableWhitelist: boolean,
    emptyContent: ?React$Node,
    noHtml: boolean,
    noHtmlExceptMatchers: boolean,
    tagName: string,
  };

  declare export class Markup extends React.Component<MarkupProps> {}

  declare export type InterweaveProps = {
    content: string,
    disableFilters: boolean,
    disableLineBreaks: boolean,
    disableMatchers: boolean,
    disableWhitelist: boolean,
    emptyContent: ?React$Node,
    filters: Filter[],
    matchers: Matcher<*>[],
    noHtml: boolean,
    noHtmlExceptMatchers: boolean,
    onAfterParse: ?AfterParseCallback,
    onBeforeParse: ?BeforeParseCallback,
    tagName: string,
  };

  declare export default class Interweave extends React.Component<InterweaveProps> {
    parseMarkup(): React$Node[];
    render(): React$Node;
  }
}

declare module 'interweave/lib/components/Element' {
  declare export default class Element extends React.PureComponent<{
    attributes: { [key: string]: string | number | boolean },
    children: React$Node,
    className: string,
    selfClose: boolean,
    tagName: string,
  }> {}
}

declare module 'interweave/lib/components/Email' {
  declare export default class Email extends React.PureComponent<{
    children: string,
    emailParts: {
      host: string,
      username: string,
    },
  }> {}
}

declare module 'interweave/lib/components/Hashtag' {
  declare export default class Hashtag extends React.PureComponent<{
    children: string,
    encodeHashtag: boolean,
    hashtagName: string,
    hashtagUrl: string | (hashtag: string) => string,
    preserveHash: boolean,
  }> {}
}

declare module 'interweave/lib/components/Link' {
  declare export default class Link extends React.PureComponent<{
    children: React$Node,
    href: string,
    newWindow: boolean,
    onClick: ?() => void,
  }> {}
}

declare module 'interweave/lib/components/Url' {
  declare export default class Url extends React.PureComponent<{
    children: string,
    urlParts: {
      auth: string,
      fragment: string,
      host: string,
      path: string,
      port: string | number,
      query: string,
      scheme: string,
    },
  }> {}
}

declare module 'interweave/lib/matchers/EmailMatcher' {
  declare export default class EmailMatcher extends Matcher<Object> {}
}

declare module 'interweave/lib/matchers/HashtagMatcher' {
  declare export default class HashtagMatcher extends Matcher<Object> {}
}

declare module 'interweave/lib/matchers/IpMatcher' {
  declare export default class IpMatcher extends Matcher<Object> {}
}

declare module 'interweave/lib/matchers/UrlMatcher' {
  declare export default class UrlMatcher extends Matcher<{
    customTLDs: string[],
    validateTLD: boolean,
  }> {}
}
